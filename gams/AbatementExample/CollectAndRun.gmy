$ONEOLCOM
$EOLCOM #


# Root File for model
OPTION SYSOUT=OFF, SOLPRINT=OFF, LIMROW=0, LIMCOL=0, DECIMALS=6;
;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\V01_functions.gms
# ----------------------------------------------------------------------------------------------------


# ----------------------------------------------------------------------------------------------------
#  Define function: load_level
# ----------------------------------------------------------------------------------------------------



# ----------------------------------------------------------------------------------------------------
#  Define function: load_fixed
# ----------------------------------------------------------------------------------------------------



# ----------------------------------------------------------------------------------------------------
#  Define function: TechLogit
# ----------------------------------------------------------------------------------------------------


# ----------------------------------------------------------------------------------------------------
#  Define function: TechNormal
# ----------------------------------------------------------------------------------------------------


# ----------------------------------------------------------------------------------------------------
#  Define function: TechLognormal
# ----------------------------------------------------------------------------------------------------



# ----------------------------------------------------------------------------------------------------
#  Define function: SolveEmptyNLP
# ----------------------------------------------------------------------------------------------------
;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\V01_sets.gms
# ----------------------------------------------------------------------------------------------------

sets
	alias_set
	alias_map2
	s
	n
;

alias(n,nn,nnn);

sets
	alias_[alias_set,alias_map2]
	V01_NT_map[s,n,nn]
	V01_NT_inp[s,n]
	V01_NT_out[s,n]
	V01_NT_int[s,n]
	V01_NT_bra_out[s,n]
	V01_NT_bra_nout[s,n]
	V01_inp[s,n]
	V01_NT_x[s,n]
	V01_x2inp[s,n,nn]
	V01_dur[s,n]
	V01_ES[s,n]
	V01_T[s,n]
	V01_inp2T[s,n,nn]
	V01_T2ES[s,n,nn]
	V01_T2ESNorm[s,n,nn]
	V01_map[s,n,nn]
;
$GDXIN %V01_DB%
$onMulti
$load alias_set
$load alias_map2
$load s
$load n
$load alias_
$load V01_NT_map
$load V01_NT_inp
$load V01_NT_out
$load V01_NT_int
$load V01_NT_bra_out
$load V01_NT_bra_nout
$load V01_inp
$load V01_NT_x
$load V01_x2inp
$load V01_dur
$load V01_ES
$load V01_T
$load V01_inp2T
$load V01_T2ES
$load V01_T2ESNorm
$load V01_map
$GDXIN
$offMulti
;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\V01_groups.gms
# ----------------------------------------------------------------------------------------------------

# Non-Technology groups:

# ----------------------------------------G_V01_NT_endo_always----------------------------------------
#  Initialize G_V01_NT_endo_always group
# ----------------------------------------------------------------------------------------------------
$offlisting
VARIABLE pS[s,n] "cost price index for outputs";
pS.L[s,n]$(V01_NT_out[s,n]) = 0;
VARIABLE pD[s,n] "cost price index for intermediates";
pD.L[s,n]$(V01_NT_int[s,n]) = 0;
VARIABLE qD[s,n] "demand for pure inputs outside Tech";
qD.L[s,n]$(V01_NT_x[s,n]) = 0;
$onlisting


# -----------------------------------------G_V01_NT_endo_base-----------------------------------------
#  Initialize G_V01_NT_endo_base group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting

# -----------------------------------------G_V01_NT_exo_always----------------------------------------
#  Initialize G_V01_NT_exo_always group
# ----------------------------------------------------------------------------------------------------
$offlisting
VARIABLE sigma[s,n] "price elasticities";
sigma.L[s,n]$((V01_NT_out[s,n]) or (V01_NT_int[s,n])) = 0;
VARIABLE qS[s,n] "output";
qS.L[s,n]$(V01_NT_out[s,n]) = 0;
$onlisting

# ------------------------------------------G_V01_NT_exo_base-----------------------------------------
#  Initialize G_V01_NT_exo_base group
# ----------------------------------------------------------------------------------------------------
$offlisting
VARIABLE mu[s,n,nn] "share parameters";
mu.L[s,n,nn]$(V01_NT_map[s,n,nn]) = 0;
$onlisting

# Technology groups

# -----------------------------------------G_V01_T_endo_always----------------------------------------
#  Initialize G_V01_T_endo_always group
# ----------------------------------------------------------------------------------------------------
$offlisting
VARIABLE lambda[s,n] "shadow cost of energy services";
lambda.L[s,n]$(V01_ES[s,n]) = 0;
$onlisting


# ------------------------------------------G_V01_T_endo_base-----------------------------------------
#  Initialize G_V01_T_endo_base group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting


# -----------------------------------------G_V01_T_exo_always-----------------------------------------
#  Initialize G_V01_T_exo_always group
# ----------------------------------------------------------------------------------------------------
$offlisting
VARIABLE theta[s,n] "technology potential";
theta.L[s,n]$(V01_T[s,n]) = 0;
$onlisting


# ------------------------------------------G_V01_T_exo_base------------------------------------------
#  Initialize G_V01_T_exo_base group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting


# Accounting groups:

# -----------------------------------------G_V01_ACC_endo_base----------------------------------------
#  Initialize G_V01_ACC_endo_base group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\V01_blocks.gms
# ----------------------------------------------------------------------------------------------------


# ----------------------------------------------M_V01_NT----------------------------------------------
#  Initialize M_V01_NT equation block
# ----------------------------------------------------------------------------------------------------
EQUATION E_V01_NT_ZP_out[s,n];
E_V01_NT_ZP_out[s,n]$(v01_nt_out[s,n]).. 		pS[s,n]*qS[s,n]	 =E=  sum(nn$(V01_map[s,nn,n]), qD[s,nn]*sum(nnn$(V01_x2inp[s,nn,nnn]), pD[s,nnn]));
EQUATION E_V01_NT_ZP_nout[s,n];
E_V01_NT_ZP_nout[s,n]$(v01_nt_int[s,n]).. 		pD[s,n]*qD[s,n]	 =E=  sum(nn$(V01_map[s,nn,n]), qD[s,nn]*sum(nnn$(V01_x2inp[s,nn,nnn]), pD[s,nnn]));
EQUATION E_V01_NT_qD_out[s,n];
E_V01_NT_qD_out[s,n]$(v01_nt_bra_out[s,n]).. 	qD[s,n]			 =E= 	sum(nn$(V01_map[s,n,nn]), mu[s,n,nn]*(pS[s,nn]/sum(nnn$(V01_x2inp[s,n,nnn]), pD[s,nnn]))**(sigma[s,nn]) * qS[s,nn]);
EQUATION E_V01_NT_qD_nout[s,n];
E_V01_NT_qD_nout[s,n]$(v01_nt_bra_nout[s,n]).. 	qD[s,n]			 =E=  sum(nn$(V01_map[s,n,nn]), mu[s,n,nn]*(pD[s,nn]/sum(nnn$(V01_x2inp[s,n,nnn]), pD[s,nnn]))**(sigma[s,nn]) * qD[s,nn]);

# ----------------------------------------------------------------------------------------------------
#  Define M_V01_NT model
# ----------------------------------------------------------------------------------------------------
Model M_V01_NT /
E_V01_NT_ZP_out, E_V01_NT_ZP_nout, E_V01_NT_qD_out, E_V01_NT_qD_nout
/;



# -------------------------------------------M_V01_T_always-------------------------------------------
#  Initialize M_V01_T_always equation block
# ----------------------------------------------------------------------------------------------------
EQUATION E_V01_T_qD[s,n];
E_V01_T_qD[s,n]$(v01_t[s,n]).. 		qD[s,n]	 =E=  sum(nn$(V01_map[s,n,nn]), (1/(1+exp((pD[s,n]-mu[s,n,nn]-lambda[s,nn])/sigma[s,nn])))) ;
EQUATION E_V01_T_pES[s,n];
E_V01_T_pES[s,n]$(v01_es[s,n]).. 	pD[s,n]	 =E=  sum(nn$(V01_map[s,nn,n]), qD[s,nn]*theta[s,nn]*pD[s,nn]);
EQUATION E_V01_T_pT[s,n];
E_V01_T_pT[s,n]$(v01_t[s,n]).. 		pD[s,n]	 =E=  sum(nn$(V01_map[s,nn,n]), mu[s,nn,n]*pD[s,nn]);

# ----------------------------------------------------------------------------------------------------
#  Define M_V01_T_always model
# ----------------------------------------------------------------------------------------------------
Model M_V01_T_always /
E_V01_T_qD, E_V01_T_pES, E_V01_T_pT
/;



# --------------------------------------------M_V01_T_base--------------------------------------------
#  Initialize M_V01_T_base equation block
# ----------------------------------------------------------------------------------------------------
EQUATION E_V01_T_sum[s,n];
E_V01_T_sum[s,n]$(v01_es[s,n]).. 	1 		 =E=  sum(nn$(V01_map[s,nn,n]), qD[s,nn]*theta[s,nn]);

# ----------------------------------------------------------------------------------------------------
#  Define M_V01_T_base model
# ----------------------------------------------------------------------------------------------------
Model M_V01_T_base /
E_V01_T_sum
/;



# ----------------------------------------------M_V01_ACC---------------------------------------------
#  Initialize M_V01_ACC equation block
# ----------------------------------------------------------------------------------------------------
EQUATION E_V01_ACC_inp[s,n];
E_V01_ACC_inp[s,n]$(v01_inp[s,n]).. 		qD[s,n]		 =E=  sum(nn$(V01_x2inp[s,nn,n]), qD[s,nn])+sum(nn$(V01_ES[s,nn]), qD[s,nn] * sum(nnn$(V01_map[s,nnn,nn] and V01_map[s,n,nnn]), mu[s,n,nnn]*qD[s,nnn]*theta[s,nnn]));

# ----------------------------------------------------------------------------------------------------
#  Define M_V01_ACC model
# ----------------------------------------------------------------------------------------------------
Model M_V01_ACC /
E_V01_ACC_inp
/;

;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\V01_groupsload.gms
# ----------------------------------------------------------------------------------------------------
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_pS[s,n] "";
    load_pS[s,n]$((V01_NT_out[s,n])) = 0;
  
    parameter load_pD[s,n] "";
    load_pD[s,n]$((V01_NT_int[s,n])) = 0;
  
    parameter load_qD[s,n] "";
    load_qD[s,n]$((V01_NT_x[s,n])) = 0;
  
  execute_load "%V01_DB%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_pS=pS.l  load_pD=pD.l  load_qD=qD.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    pS.l[s,n]$((V01_NT_out[s,n])) = load_pS[s,n];
  
    pD.l[s,n]$((V01_NT_int[s,n])) = load_pD[s,n];
  
    qD.l[s,n]$((V01_NT_x[s,n])) = load_qD[s,n];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_qD[s,n] "";
    load_qD[s,n]$(((V01_NT_inp[s,n] and not V01_NT_x[s,n]) or (V01_NT_int[s,n]))) = 0;
  
  execute_load "%V01_DB%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_qD=qD.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    qD.l[s,n]$(((V01_NT_inp[s,n] and not V01_NT_x[s,n]) or (V01_NT_int[s,n]))) = load_qD[s,n];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_lambda[s,n] "";
    load_lambda[s,n]$((V01_ES[s,n])) = 0;
  
    parameter load_pD[s,n] "";
    load_pD[s,n]$((V01_ES[s,n])) = 0;
  
  execute_load "%V01_DB%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_lambda=lambda.l  load_pD=pD.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    lambda.l[s,n]$((V01_ES[s,n])) = load_lambda[s,n];
  
    pD.l[s,n]$((V01_ES[s,n])) = load_pD[s,n];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_qD[s,n] "";
    load_qD[s,n]$((V01_T[s,n])) = 0;
  
    parameter load_pD[s,n] "";
    load_pD[s,n]$((V01_T[s,n])) = 0;
  
  execute_load "%V01_DB%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_qD=qD.l  load_pD=pD.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    qD.l[s,n]$((V01_T[s,n])) = load_qD[s,n];
  
    pD.l[s,n]$((V01_T[s,n])) = load_pD[s,n];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_qD[s,n] "";
    load_qD[s,n]$((V01_inp[s,n])) = 0;
  
  execute_load "%V01_DB%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_qD=qD.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    qD.l[s,n]$((V01_inp[s,n])) = load_qD[s,n];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_sigma[s,n] "";
    load_sigma[s,n]$(((V01_NT_out[s,n]) or (V01_NT_int[s,n]))) = 0;
  
    parameter load_pD[s,n] "";
    load_pD[s,n]$((V01_inp[s,n])) = 0;
  
    parameter load_qS[s,n] "";
    load_qS[s,n]$((V01_NT_out[s,n])) = 0;
  
  execute_load "%V01_DB%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_sigma=sigma.l  load_pD=pD.l  load_qS=qS.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    sigma.fx[s,n]$(((V01_NT_out[s,n]) or (V01_NT_int[s,n]))) = load_sigma[s,n];
  
    pD.fx[s,n]$((V01_inp[s,n])) = load_pD[s,n];
  
    qS.fx[s,n]$((V01_NT_out[s,n])) = load_qS[s,n];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_mu[s,n,nn] "";
    load_mu[s,n,nn]$((V01_NT_map[s,n,nn])) = 0;
  
  execute_load "%V01_DB%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_mu=mu.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    mu.fx[s,n,nn]$((V01_NT_map[s,n,nn])) = load_mu[s,n,nn];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_theta[s,n] "";
    load_theta[s,n]$((V01_T[s,n])) = 0;
  
    parameter load_mu[s,n,nn] "";
    load_mu[s,n,nn]$(((V01_T2ESNorm[s,n,nn]) or (V01_inp2T[s,n,nn] and not V01_dur[s,n]))) = 0;
  
    parameter load_sigma[s,n] "";
    load_sigma[s,n]$((V01_ES[s,n])) = 0;
  
  execute_load "%V01_DB%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_theta=theta.l  load_mu=mu.l  load_sigma=sigma.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    theta.fx[s,n]$((V01_T[s,n])) = load_theta[s,n];
  
    mu.fx[s,n,nn]$(((V01_T2ESNorm[s,n,nn]) or (V01_inp2T[s,n,nn] and not V01_dur[s,n]))) = load_mu[s,n,nn];
  
    sigma.fx[s,n]$((V01_ES[s,n])) = load_sigma[s,n];
$onlisting
;
$offlisting
  
# --------------------------------------------__load_group--------------------------------------------
#  Initialize __load_group group
# ----------------------------------------------------------------------------------------------------
$offlisting
$onlisting
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    parameter load_mu[s,n,nn] "";
    load_mu[s,n,nn]$(((V01_inp2T[s,n,nn] and V01_dur[s,n]) or (V01_T2ES[s,n,nn] and not V01_T2ESNorm[s,n,nn]))) = 0;
  
  execute_load "%V01_DB%" 
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------
 load_mu=mu.l ;
  
# ----------------------------------------------------------------------------------------------------
#  Loop over __load_group
# ----------------------------------------------------------------------------------------------------

    mu.fx[s,n,nn]$(((V01_inp2T[s,n,nn] and V01_dur[s,n]) or (V01_T2ES[s,n,nn] and not V01_T2ESNorm[s,n,nn]))) = load_mu[s,n,nn];
$onlisting
;
;

# ----------------------------------------------------------------------------------------------------
#  Import file: C:\Users\sxj477\Documents\GitHub\GPM_v05\work_folder\RunFile.gms
# ----------------------------------------------------------------------------------------------------


# ----------------------------------------------------------------------------------------------------$FIX G_V01_NT_exo_always, G_V01_NT_exo_base, G_V01_T_exo_always, G_V01_T_exo_base;
# ----------------------------------------------------------------------------------------------------
$offlisting
sigma.FX[s,n]$((V01_ES[s,n]) or ((V01_NT_out[s,n]) or (V01_NT_int[s,n]))) = sigma.L[s,n];
pD.FX[s,n]$(V01_inp[s,n]) = pD.L[s,n];
qS.FX[s,n]$(V01_NT_out[s,n]) = qS.L[s,n];
mu.FX[s,n,nn]$(((V01_inp2T[s,n,nn] and V01_dur[s,n]) or (V01_T2ES[s,n,nn] and not V01_T2ESNorm[s,n,nn])) or (((V01_T2ESNorm[s,n,nn]) or (V01_inp2T[s,n,nn] and not V01_dur[s,n])) or (V01_NT_map[s,n,nn]))) = mu.L[s,n,nn];
theta.FX[s,n]$(V01_T[s,n]) = theta.L[s,n];
$onlisting

# ----------------------------------------------------------------------------------------------------$UNFIX G_V01_NT_endo_always, G_V01_NT_endo_base, G_V01_T_endo_always, G_V01_T_endo_base, G_V01_ACC_endo_base;
# ----------------------------------------------------------------------------------------------------
$offlisting
pS.lo[s,n]$(V01_NT_out[s,n]) = -inf;
pS.up[s,n]$(V01_NT_out[s,n]) = inf;
pD.lo[s,n]$((V01_T[s,n]) or ((V01_ES[s,n]) or (V01_NT_int[s,n]))) = -inf;
pD.up[s,n]$((V01_T[s,n]) or ((V01_ES[s,n]) or (V01_NT_int[s,n]))) = inf;
qD.lo[s,n]$((V01_inp[s,n]) or ((V01_T[s,n]) or (((V01_NT_inp[s,n] and not V01_NT_x[s,n]) or (V01_NT_int[s,n])) or (V01_NT_x[s,n])))) = -inf;
qD.up[s,n]$((V01_inp[s,n]) or ((V01_T[s,n]) or (((V01_NT_inp[s,n] and not V01_NT_x[s,n]) or (V01_NT_int[s,n])) or (V01_NT_x[s,n])))) = inf;
lambda.lo[s,n]$(V01_ES[s,n]) = -inf;
lambda.up[s,n]$(V01_ES[s,n]) = inf;
$onlisting

# ----------------------------------------------------------------------------------------------------
#  Define V01_B model
# ----------------------------------------------------------------------------------------------------
Model V01_B /
E_V01_NT_ZP_out, E_V01_NT_ZP_nout, E_V01_NT_qD_out, E_V01_NT_qD_nout, E_V01_T_qD, E_V01_T_pES, E_V01_T_pT, E_V01_T_sum, E_V01_ACC_inp
/;

scalars V01_B_modelstat, V01_B_solvestat;
solve V01_B using CNS;
V01_B_modelstat = V01_B.modelstat; V01_B_solvestat = V01_B.solvestat;
;
